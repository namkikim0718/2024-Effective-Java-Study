# 불필요한 객체 생성을 피하라.
</br>

다음 코드를 먼저 보자.
```java
String s = new String("bikini");
```
이 문장은 실행될 때마다 String 인스턴스를 새로 만드는 쓸데없는 행위이다.</br>
이 코드가 반복문이나 빈번히 호출되는 메서드 안에 있다면 새로운 인스턴스가 수백만 개 만들어질 수도 있다.</br></br>

```java
String s = "bikini";
```
이 코드는 우리가 흔히 문자열을 생성할 때 사용하는데, 매번 새로운 인스턴스를 생성하는 것이 아니라, 하나의 String 인스턴스를 사용하는 것이다.</br>
이 방식은 문자열 s를 사용하는 모든 코드가 같은 객체를 사용함을 보장한다.</br>
</br>

생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 `정적 팩터리 메서드`를 이용해 불필요한 객체 생성을 피할 수 있다.</br>
예로 `Boolean(String)` 생성자 대신 `Boolean.valueOf(String)` 팩터리 메서드를 사용하는 것이 좋다.</br>
> `생성자`는 호출할 때마다 새로운 객체를 만들지만, `팩터리 메서드`는 그렇지 않다.</br>
> 가변 객체라 해도 사용 중에 변경되지 않을 것을 안다면 재사용이 가능하다.

</br></br>

## 생성 비용이 큰 객체

```java
public class RomanNumerals {
    // 코드 6-1 성능을 훨씬 더 끌어올릴 수 있다!
    static boolean isRomanNumeralSlow(String s) {
        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
                + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }
}
```
위의 코드는 `String.matches`메서드를 사용한다는 데에 있다. 이 방법은 정규표현식으로 문자열 형태를 확인하기 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기에 적합하지 않다.</br>
`Pattern`은 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)을 만들기 때문에 인스턴스 생성 비용이 높다.</br>

성능을 개선시키기 위해서는 `Pattern` 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두고 재사용하는 것이 좋다.</br></br>

```java
public class RomanNumerals {
    // 코드 6-2 값비싼 객체를 재사용해 성능을 개선한다.
    private static final Pattern ROMAN = Pattern.compile(
            "^(?=.)M*(C[MD]|D?C{0,3})"
                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeralFast(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```
이렇게 개선하면 `Pattern`을 재사용해 개선 전 코드에 비해 약 6.5배 정도 더 빠르게 동작할 수 있으며, 코드도 더 명확해진다.</br></br></br>

## 불필요한 객체를 생성하는 예

### 1. 어댑터(뷰)

</br>

어댑터는 실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체다.</br>
즉, 어댑터는 뒷단 객체 말고는 관리할 상태가 없으므로 객체당 하나의 어댑터만 만들어지면 충분하다. </br></br>

```java
Map<String, String> map = new HashMap<>();
map.put("key1", "value1");

Set<String> set1 = map.keySet();
Set<String> set2 = map.keySet();
```
위의 코드처럼 `keySet`메서드는 `map`인스턴스를 대변하는 어댑터이다.</br>
`set1`이나 `set2`나 둘다 `map`인스턴스를 대변하는데 굳이 여러개를 만들 이유가 있을까?</br>
___그럴 필요도 없고 이득도 없다.___</br></br></br>
  
### 2. 오토박싱(auto boxing)

</br>

`오토박싱`은 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술이다.</br></br>

```java
private static long sum() {
        Long sum = 0L;
        for (long i = 0; i <= Integer.MAX_VALUE; i++)
            sum += i;
        return sum;
}
```
여기서 `Long`타입인 `sum`에 `long`타입인 `i`를 더해가면서 불필요한 `Long` 인스턴스가 약 2^31개나 만들어져, 매우 느리게 동작한다.</br>
이 코드로 얻을 수 있는 교훈은 ___"박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자"___ 이다.</br></br>

### 그렇다면 객체 생성은 비싸니 무조건 피해야 할까?

</br>

아니다. 요즘의 JVM에서는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않는다. 프로그램의 `명확성`, `간결성`, `기능`을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.</br>
데이터베이스 연결 같이 생성 비용이 아주 비싼 경우가 아닌 이상 자체 객체 풀을 만들어 사용하는 것은 오히려 코드를 헷갈리게 만들고, 메모리 사용량을 늘려 성능이 저하된다.</br>

## 객체 재사용 vs 새로운 객체 생성</br>
이번 아이템은 `방어적 복사`를 다루는 아이템 50과 대조적이다.</br>
이번 내용은 ___"기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라"___ 이고,</br>
아이템 50은 ___"새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라"___ 이다.</br></br>

불필요한 객체 생성은 코드 형태와 성능에만 영향을 준다. 그러나 `방어적 복사`가 필요한 상황에서 객체를 재사용하면 피해는 훨씬 크다.
